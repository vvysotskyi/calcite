# sub-query.iq - Queries involving IN and EXISTS sub-queries
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
!use post
!set outputformat psql

# [CALCITE-373]
# the following should return no rows, because the IN list has a null.
# for details on this: see HIVE-784, Dayal's paper from VLDB-87
with
t1(x) as (select * from  (values 1,2, case when 1 = 1 then null else 3 end)),
t2(x) as (select * from  (values 1,case when 1 = 1 then null else 3 end))
select *
from t1
where t1.x not in (select t2.x from t2);
 X
---
(0 rows)

!ok
EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], expr#6=[=($t1, $t5)], expr#7=[false], expr#8=[IS NOT NULL($t4)], expr#9=[true], expr#10=[IS NULL($t0)], expr#11=[null], expr#12=[<($t2, $t1)], expr#13=[CASE($t6, $t7, $t8, $t9, $t10, $t11, $t12, $t9, $t7)], expr#14=[NOT($t13)], EXPR$0=[$t0], $condition=[$t14])
  EnumerableJoin(condition=[=($0, $3)], joinType=[left])
    EnumerableJoin(condition=[true], joinType=[inner])
      EnumerableUnion(all=[true])
        EnumerableCalc(expr#0=[{inputs}], expr#1=[1], EXPR$0=[$t1])
          EnumerableValues(tuples=[[{ 0 }]])
        EnumerableCalc(expr#0=[{inputs}], expr#1=[2], EXPR$0=[$t1])
          EnumerableValues(tuples=[[{ 0 }]])
        EnumerableCalc(expr#0=[{inputs}], expr#1=[true], expr#2=[null], expr#3=[3], expr#4=[CASE($t1, $t2, $t3)], EXPR$0=[$t4])
          EnumerableValues(tuples=[[{ 0 }]])
      EnumerableAggregate(group=[{}], c=[COUNT()], ck=[COUNT($0)])
        EnumerableUnion(all=[true])
          EnumerableCalc(expr#0=[{inputs}], expr#1=[1], EXPR$0=[$t1])
            EnumerableValues(tuples=[[{ 0 }]])
          EnumerableCalc(expr#0=[{inputs}], expr#1=[true], expr#2=[null], expr#3=[3], expr#4=[CASE($t1, $t2, $t3)], EXPR$0=[$t4])
            EnumerableValues(tuples=[[{ 0 }]])
    EnumerableAggregate(group=[{0, 1}])
      EnumerableCalc(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])
        EnumerableUnion(all=[true])
          EnumerableCalc(expr#0=[{inputs}], expr#1=[1], EXPR$0=[$t1])
            EnumerableValues(tuples=[[{ 0 }]])
          EnumerableCalc(expr#0=[{inputs}], expr#1=[true], expr#2=[null], expr#3=[3], expr#4=[CASE($t1, $t2, $t3)], EXPR$0=[$t4])
            EnumerableValues(tuples=[[{ 0 }]])
!plan

# Use of case is to get around issue with directly specifying null in values
# list. Postgres gives 0 rows.
with
t1(x) as (select * from  (values (1),(2),(case when 1 = 1 then null else 3 end)) as t1),
t2(x) as (select * from  (values (1),(case when 1 = 1 then null else 3 end)) as t2)
select *
from t1
where t1.x not in (select t2.x from t2);

 X
---
(0 rows)

!ok

# RHS has a mixture of NULL and NOT NULL keys
select * from dept where deptno not in (select deptno from emp);
 DEPTNO | DNAME
--------+-------
(0 rows)

!ok
select deptno, deptno     in (select deptno from emp) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | true
     20 | true
     30 | true
     40 | null
(4 rows)

!ok
select deptno, deptno not in (select deptno from emp) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | false
     20 | false
     30 | false
     40 | null
(4 rows)

!ok

# RHS has only NULL keys
select * from dept where deptno not in (select deptno from emp where deptno is null);
 DEPTNO | DNAME
--------+-------
(0 rows)

!ok
select deptno, deptno     in (select deptno from emp where deptno is null) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | null
     20 | null
     30 | null
     40 | null
(4 rows)

!ok
select deptno, deptno not in (select deptno from emp where deptno is null) from dept;
 DEPTNO | EXPR$1
--------+--------
     10 | null
     20 | null
     30 | null
     40 | null
(4 rows)

!ok

# End sub-query.iq
